\chapter{Comparing Algorithms}


% it 1
With the {\tt norMmix} package explained, we can turn to comparing it to 
existing methods. As previously stated, the implementation representing the 
EM-algorithm is the {\tt mclust} package. It will be used with very little 
deviation from out-of-the-box, safe for restriction to the covariance models.
This is done, so we can compare like with like.
The specific command that performs the EM-algorithm is:
<<mclustcall, echo=TRUE, results=hide>>=
    #mclust::Mclust(x, G=cl, modelNames=mo)$BIC
@
Where {\tt cl} is a vector of integers of however many components we are trying to fit and {\tt mo} are the model names:
<<modelnames, echo=FALSE, results=verbatim>>=
    library(norMmix, lib.loc="~/ethz/BA/norMmix.Rcheck/")
    norMmix:::mods()
@
The {\tt \$BIC} element of the results is taken as the main tool for model 
selection, as it is advertised in the package authors paper \cite{Scr16}.

There is however a small but crucial change applied to these results.
The {\tt mclust} package authors have flipped the definition of the BIC to mean:
\[ 2 ln(\hat{L}) - ln(n) \theta\]
instead of the more common
\[ ln(n) \theta - 2 ln(\hat{L}) \]
Where $n$ is the number of observations, $\theta$ is the cardinality of the 
parameter vector and $\hat{L}$ is the estimated log-likelihood.

So even if not explicitly mentioned, we use the negative of the values returned
by {\tt mclust}.


% it 1
here show bic type plots, how to read them, and what we're trying to compare
i.e. clara, mclVVV, mclust.

First, we illustrate the structure of the graphical results we will be 
presenting hereafter. The basic shape of the plots will be the BIC value 
plotted against the number of components. This is in line with {\tt mclust}'s
manner of visualizing data, however since our method is to some extent RNG 
dependent, we are forced to display multiple runs of the algorithm on the same
graph. Therefore we split the plot according to covariance model, putting 10
models in 10 graphs in a plot. Here an example:

<<bicplotdemo, echo=FALSE, results=hide>>=
    savdir <- normalizePath("~/ethz/BA/Rscripts/2time")
    fin <- list.files(savdir, pattern="MW34_size=0500_seed")
    finmclust <- list.files(savdir, pattern="MW34_size=0500__mcl.rds")
    bic <- massbic(fin, savdir)
    bicmclust <- readRDS(file.path(savdir, finmclust))
@

\begin{figure}
    \centering
<<bicplotdemoplot, echo=FALSE, fig=TRUE>>=
    compplot(bic, bicmclust, main="Example Plot")
    legend("right", legend="asdf", fill=c("red", "blue"))
@
    \caption{Example of Comparison Plot}
    \label{fig:ExPlot}
\end{figure}

As can be seen from the formula of the BIC value, lower is better. When 
selecting a model based on BIC, we take the model and component with the 
lowest value to be the best fitting model. Although this may not necessarily
the 'correct' model, that is, the model from which the data arises.

There are many ways in which this type of model selection might miss the 
correct model, for example by 'gluing together' multiple components into one,
or covering the dataset in a 'patchwork' of smaller components, to name a few.

We will discuss them as they arise in the following analysis of simulations

here explain simulations conducted, \ref{App:sims}
here explain the various sections: time, n, p, difficult , nonnormal 

\section{Time Analysis}

here how much time they take, in p,k and n give approximate O(x) value

<<time, echo=TRUE>>=
    library(norMmix, lib.loc="~/ethz/BA/norMmix.Rcheck/")
    # change this dir to whereever the simulations are saved
    mainsav <- normalizePath("~/ethz/BA/Rscripts/")

    savdir <- file.path(mainsav, "2time")
    filelist <- list.files(savdir, pattern=".rds")
    filelist <- grep("mcl.rds", filelist, invert=TRUE, value=TRUE)
    ## need to split these better
    f <- lapply(file.path(savdir,filelist), function(j) readRDS(j)$fit)
    times <- unlist(lapply(f, function(j) extracttimes(j)[,,1]))
    dims <- unlist(lapply(f, function(j) attr(extracttimes(j), "p")))
    size <- unlist(lapply(f, function(j) attr(extracttimes(j), "n")))

    ddims <- rep(dims, each=80)
    ssize <- rep(size, each=80)

    pars <- unlist(lapply(f, npar))


    r <- lm(log(times) ~ log(pars) + log(ddims) + log(ssize))
    summary(r)
@

\begin{figure}[h]
    \centering
<<figtime, echo=TRUE, fig=TRUE>>=
    plot(times~pars, log="xy", yaxt="n", xaxt="n")
    sfsmisc::eaxis(1)
    sfsmisc::eaxis(2)
@
    \caption{Log-log Plot of System Time against Parameter Length}
    \label{fig:time}
\end{figure}

can see that time is almost one to one proportional to parameter length.

\section{Behaviour in {\tt n}}

% it 1
here show as expected narrower scattering as n increases

<<nfit, echo=FALSE>>=
    savdir <- file.path(mainsav, "2time")
    filenames <- list.files(savdir, pattern="seed=")
    size05 <- grep("size=0500", filenames, value=TRUE)
    size10 <- grep("size=1000", filenames, value=TRUE)
    size20 <- grep("size=2000", filenames, value=TRUE)

    size05mw34 <- grep("MW34", size05, value=TRUE)
    size05mw51 <- grep("MW51", size05, value=TRUE)
    size05mw214 <- grep("MW214", size05, value=TRUE)

    size10mw34 <- grep("MW34", size10, value=TRUE)
    size10mw51 <- grep("MW51", size10, value=TRUE)
    size10mw214 <- grep("MW214", size10, value=TRUE)

    size20mw34 <- grep("MW34", size20, value=TRUE)
    size20mw51 <- grep("MW51", size20, value=TRUE)
    size20mw214 <- grep("MW214", size20, value=TRUE)

    s05mw34bic <- massbic(size05mw34, savdir)
    s10mw34bic <- massbic(size10mw34, savdir)

    mfn <- list.files(savdir, pattern="mcl.rds")
    ## mclust bic values
    # MW214
    m05214 <- readRDS(file.path(savdir,mfn[1]))
    m10214 <- readRDS(file.path(savdir,mfn[2]))
    m20214 <- readRDS(file.path(savdir,mfn[3]))
    # MW34
    m0534 <- readRDS(file.path(savdir,mfn[4]))
    m1034 <- readRDS(file.path(savdir,mfn[5]))
    m2034 <- readRDS(file.path(savdir,mfn[6]))
    # MW51
    m0551 <- readRDS(file.path(savdir,mfn[7]))
    m1051 <- readRDS(file.path(savdir,mfn[8]))
    m2051 <- readRDS(file.path(savdir,mfn[9]))
@

\begin{figure}[h]
    \centering
<<fig5fit, fig=TRUE>>=
    compplot(s05mw34bic, m0534)
@
\end{figure}[h]
\begin{figure}
<<fig10fit, fig=TRUE>>=
    compplot(s10mw34bic, m1034)
@
\end{figure}


\section{Behaviour in {\tt p}}

% it 1
here show how norMmix is consistently competitive with mclust

\begin{figure}[h]
<<figMW34, fig=TRUE>>=
    plot(MW34)
@
\end{figure}


<<MW34fit, echo=FALSE>>=
    savdir <- file.path(mainsav, "2init")
    filenames <- list.files(savdir, pattern=".rds")
    MW34fn <- grep("MW34", filenames, value="TRUE")
    mclustfiles <- grep("mcl.rds", MW34fn, value=TRUE)
    MW34fn <- grep("mcl.rds", MW34fn, value="TRUE", invert=TRUE)
    claraMW <- grep("clara", MW34fn, value=TRUE)
    mclMW <- grep("mclVVV", MW34fn, value=TRUE)
    clarabic <- massbic(claraMW, savdir)
    mclbic <- massbic(mclMW, savdir)
    mclustbic <- readRDS(file.path(savdir,mclustfiles[1]))
@

\begin{figure}[h]
<<figMW34bic, fig=TRUE>>=
    compplot(clarabic, mclbic, mclustbic, main="Fit of MW34")
@
\end{figure}

\section{Diffixult Mixtures}

% it 1
here show behaviour in difficult cases

\begin{figure}[h]
<<figMW214, fig=TRUE>>=
    plot(MW214)
@
\end{figure}


<<MW214fit>>=
    savdir <- file.path(mainsav, "2init")
    filenames <- list.files(savdir, pattern=".rds")
    MW214fn <- grep("MW214", filenames, value="TRUE")
    mclustfiles <- grep("mcl.rds", MW214fn, value=TRUE)
    MW214fn <- grep("mcl.rds", MW214fn, value="TRUE", invert=TRUE)
    claraMW <- grep("clara", MW214fn, value=TRUE)
    mclMW <- grep("mclVVV", MW214fn, value=TRUE)
    clarabic <- massbic(claraMW, savdir)
    mclbic <- massbic(mclMW, savdir)
    mclustbic <- readRDS(file.path(savdir,mclustfiles[1]))
@

\begin{figure}[h]
<<figMW214bic, fig=TRUE>>=
    compplot(clarabic, mclbic, mclustbic, main="Fit of MW214")
@
\end{figure}

here some examples of fitted mixtures

\begin{figure}
    \centering
<<fig214fit, fig=TRUE>>=
    f <- readRDS(file.path(savdir, claraMW[28]))
    ff <- f$fit$nMm[8,8][[1]]
    plot(ff$norMmix)
    #points(ff$x)
@
\end{figure}

We can see, that, subtracting the obvious hiccups of the small erroneous
components, {\tt norMmix} has correctly found the 'intended' 
distribution. This is remarkable, given the small sample size and difficulty of distribution

\section{Nonnormal Mixtures}

here 2smi and 2var, maybe others as well.


here 2smi:

<<2smi>>=
    savdir <- file.path(mainsav, "2smi")
    filenames <- list.files(savdir, pattern=".rds")
    fnclara <- grep("clara_seed", filenames, value=TRUE)
    fnmclVV <- grep("mclVVV_see", filenames, value=TRUE)
    fnmclus <- grep("__mcl.rds",  filenames, value=TRUE)
@

\begin{figure}[h]
    \centering
<<2smiplot, echo=FALSE, fig=TRUE>>=
    fnclbic <- massbic(fnclara, savdir)
    fnmcbic <- massbic(fnmclVV, savdir)
    mcbic <- readRDS(file.path(savdir, fnmclus[1]))

    compplot(fnclbic, fnmcbic, mcbic, main="BIC of SMI.12")
@
\end{figure}

While not very spectacular, the graphs show that even at large parameter
counts our algorithm closes in on the same values as {\tt mclust}.
At these dimensions it is difficult to compare if these are actually 
equal, or even similar fits, but going by BIC values, it is at the very 
least equally viable as a working model.

To illustrate, here are the parameter sizes for this simulation:
<<2smiparams, echo=FALSE, results=verbatim>>=
    f <- readRDS(file.path(savdir, fnclara[1]))
    npar(f$fit)
@


